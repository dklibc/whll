WHLL -- White Horse Linux Loader. Мой собственный простой как молоток загрузчик
ядра Linux для ПК. Я начал его писать в середине января 2016 года, а закончил в
середине февраля. Зачем нужен ещё один загрузчик? Потому что я не люблю LILO и
GRUB, а GRUB2 вообще пиздец. Я всегда думал и думаю, что загрузчик должен быть
очень простым, а они из него делают вундервафлю какую-то с сотней настроек в
конфиге и с поддержкой десятка файловых систем. Что, конечно, не удивительно, с
учётом того, что один или несколько человек в течение нескольких лет сидят над
проектом и думают, чего бы ещё добавить. Я упал под стол, когда узнал, что
конфиги для GRUB2 вообще редактируются не в ручную, а с помощью спец.
утилиты... блядь, СУБД не хватает!

Почему WHLL? Просто потому, что когда писал прототип, я попивал дешёвый скоч --
"Белую Лошадь". Тогда я думал, что написать свой Linux загрузчик это прикольно.
Да и опыт программирования на асме x86 у меня был.

Сначала я хотел реализовать в загрузчике чтение файловой системы EXT2, чтобы
как GRUB читать ядро прямо из файловой системы. Но потом понял, что это не
очень легко, хотя в принципе реализуемо. Тогда я начал копать в сторону LILO:
LILO загружает ядро также прямо из ФС, но не знает об ФС ничего. Как же так?
Очень просто: спец. утилита создаёт файл, который содержит список блоков файла
ядра, и каждый блок файла содержит номер следующего блока, а в теле загрузчика
есть номер первого блока. Таким образом LILO находит блоки, которые занимает
блок ядра на диске. Дельно. И при каждом изменении файла ядра нужно
пересоздавать этот файл, чтобы в нём отразились изменения. Но как узнать в
каком блоке на диске (в разделе диска) какой блок файла содержится, т.е. что
блок N файла содержится в блоке M раздела диска? Есть в Linux спец. функция --
fbmap, которая сообщает требуемую информацию, я пробовал. Но всё равно, мне не
понравилось. И вот почему:

По-моему, загрузчик должен быть как можно проще, и заставлять его понимать
ФС -- это явный перебор. Поэтому я решил, что загрузчик и ядро у меня будут на
отдельном разделе без ФС: сначала загрузчик, а потом сразу за ним ядро. Тогда
всё просто и элегантно — чисто административное решение. Хех, под загрузчик в
EXT2 выделяют первые 2 сектора (1КБ), видно 1КБ кода хватит для написания
загрузчика, который бы мог грузить ядро из EXT2 (а если не хватит, можно
запаковать код и распаковывать уже в памяти).

Ещё я решил, что загрузчик не должен писать длинные описательные сообщения об
ошибках и сообщения о том, к какой стадии он приступает. Почему? Потому что они
занимают много места, а я хотел уложиться в 512 байт, чтобы всё было
элегантно -- без подгрузки своего хвоста с диска. Здесь я взял пример с LILO: о
прохождении каждой стадии загрузчик уведомляет пользователя одной буквой в
след. позицию на экран, а в случае ошибки выводит букву 'E'. Т.о. можно будет
понять, на какой стадии произошла ошибка. А так же при успешной загрузке
очередного блока ядра загрузчик выводит символ '-' в след. позицию на экране,
чтобы можно было визуально проконтролировать его работу (имело смысл при первом
запуске для того, чтобы можно было убедиться в его работоспособности).

Сам код я написал на FASM — отличный ассемблер. Мой любимый. Код v1 поместился
в 512 байт.

Как оказалось, ядра Linux имеют несколько разных форматов (по-моему 2), которые
различаются протоколом загрузки. Большая разница в том, что ранние ядра linux
были маленькими и помещались в PC convenient memory (нижние 640КБ), а сейчас
ядра стали больше 1МБ, поэтому их нужно грузить в Extended Memory (веше первого
МБ), а эти адреса в лоб не доступны в 16-bit real-mode процессора x86 —
требуются ухищрения. Я использовал unreal-mode.

Я остановился на протоколе загрузки ядра версии 2.2, потому что он используется
на ядрах, начиная с 2.4, а более ранние я не использовал никогда.

Для загрузки секторов диска я юзал LBA функции BIOS int 0x13.

Написал, установил, заработало! Чуть-ли не с первого раза! Вот так-то --я крут.

v1.1 Через год, в конце декабре 2016 (29 декабря!!), появилась необходимость
немного доработать мой загрузчик: добавить возможность грузить второе ядро и
возможность передавать ядру командную строку. Зачем всё это? Ну... грузить
второе ядро полезно, когда скомпилил новое ядро, а оно не загрузилось. Тогда
нужно загрузиться со старого. А передавать командную строку... Например, для
того, чтобы передать init процессу параметр -- "boot in single-user system
maintenance mode"

Сказано -- сделано. За день я дописал код, причём исправлений в предыдущем
вообще не было -- чисто добавление новых функций. Вот так виртуозно, мне аж
самому понравилось, как аккуратно получилось. Но размер вырос -- в 512 байт не
уложился. Размер стал где-то 855 байт. Пришлось подгружать ещё один сектор. А
всё из-за длинных сообщений.

Короче стало так: если пользователь хочет воспользоваться новыми фичами
(загрузить второе ядро или передать ядру командную строку), то он должен в
процессе загрузки ПК многократно нажимать F3, пока не увидит приветствие
загрузчика. Он задаст вопрос: "Хотите загрузить второе ядро?" Можете ответить
'y', если вам это нужно, и вы заранее установили его в тот же раздел, после
первого (на первое ядро резервируется 5000 секторов. NOTE: сейчас моё ядро 2.6
занимает где-то 2480 секторов, так что с запасом). Т.е. в разделе первые два
сектора -- загрузчик, следом идёт первое ядро, считаем, что под него уходит
5000 секторов, а потом идёт следующее. Вот так всё просто и элегантно.

Потом загрузчик попросит вас ввести командную строку, которую он передаст
загружаемому ядру. Вводимую строку можно ограниченно редактировать с помощью
клавиши Backspace.
